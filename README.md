
# mongoose-track-changes

This is a [Mongoose](https://github.com/Automattic/mongoose) plugin that tracks every change that is made to a model at runtime in a transparent
way for the developer. It allows to restore the previous value for any given path, or check if a given path has changed
in a very easy, performant and efficient way.

## Installation and usage
For the time being we do not provide an npm package, so in order to install this plugin you will need to do the following:
```bash
npm i --save https://github.com/Walcu-Engineering/mongoose-track-changes
```
To use the plugin in your code base:
```javascript
const trackChangesPlugin = require('mongoose-track-changes');
const mongoose = require('mongoose');

const notificationSchema = mongoose.Schema({
  notify_at: Date,
  notify_to: [{type: mongoose.Schema.Types.ObjectId}],
  done_by: {type: mongoose.Schema.Types.ObjectId},
});

notificationSchema.plugin(trackChangesPlugin);

notificationSchema.pre('save', function(next){
  if(this.pathHasChanged('/done_by')){
    this.set('notify_to', [this.getPreviousValue('/done_by')]);
  }
  next();
});
```

## `Change` specification
Each change is an object with 2 keys:

**- `path`**
A string representing a path in JSON Pointer format as defined by the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901)

**- `old_value`**
Any value representing the previous value that there was in the path specified in the `path` key described above.

## Are the changes stored in the database?
The changes array is not stored in the database, this array only lives at runtime in `$locals.changes` document path.

## What if I want to store the changes in the database?
This plugin does not support this feature right now and we do not guarantee that this feature will be implemented in the future.

## Where do the changes live?
All the changes are stored in an `array` at runtime in the `$locals.changes` property of the document model.

## How do I work with the changes?
You don't need to work with the `$locals.changes` array because this plugin injects two helper methods to every
document that should be enough to achieve whatever you wish to accomplish.
## API
This plugin provide two helper methods available in all models, and they should be enough to achieve whatever you wish:
### `pathHasChanged`
  **Parameters**

  - `path`: (Optional) A string representing a path in JSON Pointer format as defined by the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901)
    *Default value is empty string

  **Returns**
  - `true`: If the `path` specified in the parameter has changed.
  - `false`: If the `path` specified in the parameter **has not** changed

  **Example**
  ```javascript
  const mtc = require('mongoose-track-changes');
  const mongoose = require('mongoose');

  const notificationSchema = mongoose.Schema({
    notify_at: Date,
    notify_to: [{type: mongoose.Schema.Types.ObjectId}],
    done_by: {type: mongoose.Schema.Types.ObjectId},
  });

  notificationSchema.plugin(mtc);

  mongoose.connect(process.env.MONGO_URL)
    .then(() => {
      const notificationModel = mongoose.model('Notification', notificationSChema);
      const notification = notificationModel({
        notify_at: new Date(),
        notify_to: new Array(3).fill(0).map(() => mongoose.Types.ObjectId()),
        done_by: mongoose.Types.ObjectId(),
      });
      return notification.save();
    }).then(saved_notification => {
      saved_notification.done_by = mongoose.Types.ObjectId();
      saved_notification.set('notify_at', new Date());
      console.log(saved_notification.pathHasChanged('/done_by'));
      //Prints true
      console.log(saved_notification.pathHasChanged('/notify_at'));
      //Prints true
      console.log(saved_notification.pathHasChanged('')); //The root path
      //Prints true
      console.log(saved_notification.pathHasChanged('/notify_to'))
      //Prints false
      console.log(saved_notification.pathHasChanged('/non/existing/path'))
      //Prints false
    }).then(() => {
      mongoose.disconnect();
    });
  ```
---
### `getPreviousValue`
  **Parameters**
  - `path`: (Optional) A string representing a path in JSON Pointer format as defined by the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901)
      *Default value is empty string

  **Returns**
  The previous value for the given path, but we aware of this very important point:
  all the descendant paths of the requested path that have not changed, **will be pointers to the current values**,
  and only the actual paths that have changed will have new data.

  This means that if you get the previous value for a path that has descendant nodes that have not changed, and then you make
  changes to those nodes in the original document, in the previous value those changes will appear as well.

  And in the same way, if you make changes in the object generated by `getPreviousValue`, to paths that have not changed in the
  original document, those changes will affect to the original document as well.

  So be careful, and **if you want to make any change to that value, make sure that you make deep clone of it.**

  **Example**
  For simplification.Let's say that we have this document:
  ```javascript
  const mydocument = {
    a0: {
      b0: {
        c0: {
          d0: {
            e0: '/a0/b0/c0/d0/e0 original value'
          }
        },
        c1: {
          d0: '/a0/b0/c1/d0 original value'
        }
      }
    },
    a1: {
      b0: '/a1/b0 original value',
      b1: '/a1/b1 original value'
    }
  }
  ```
  And we do a single change:
  ```javascript
  mydocument.a0.b0.c0.d0.e0 = '/a0/b0/c0/d0/e0 new value';
  ```
  So now the document is:
  ```javascript
  {
    a0: {
      b0: {
        c0: {
          d0: {
            e0: '/a0/b0/c0/d0/e0 new value'
          }
        },
        c1: {
          d0: '/a0/b0/c1/d0 original value'
        }
      }
    },
    a1: {
      b0: '/a1/b0 original value',
      b1: '/a1/b1 original value'
    }
  }
  ```
  And we have a single change that is
  ```javascript
  {path: '/a0/b0/c0/d0/e0', old_value: '/a0/b0/c0/d0/e0 original value'}
  ```
  So now if we want the previous value for the path `/a0/b0/c0/d0/e0`:
  ```javascript
  mydocument.getPreviousValue('/a0/b0/c0/d0/e0');
  ```
  The result will be just `'/a0/b0/c0/d0/e0 original value'`, but if you call the function with `'/a0/b0'`
  ```javascript
  const prev = mydocument.getPreviousValue('/a0/b0');
  ```
  Then `prev` result will be
  ```javascript
  {
    c0: {
      d0: {
        e0: '/a0/b0/c0/d0/e0 original value'
      }
    },
    c1: {//Pointer to the original value because this branch has not changed
      d0: '/a0/b0/c1/d0 original value'
    }
  }
  ```
  And if for some reason you update the original document like this:
  ```javascript
  const prev = original.getPreviousValue('/a0/b0');
  console.log(prev.c1.d0)
  //Prints '/a0/b0/c1/d0 original value'
  original.a0.b0.c1.d0 = 'changed after getting prev'.
  console.log(prev.c1.d0);
  //Prints 'changed after getting prev'.
  prev.c1.d0 = 'I am changing this from the prev';
  console.log(original.a0.b0.c1.d0);
  //Prints 'I am changing this from the prev'
  ```
  So be very very careful with this.

---
### `is` (Available from v 1.2.0)
  **Parameters**
  - `path`: A string representing a path in JSON Pointer format as defined by the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901)
  - `value`: Any value.

  **Returns**
  Boolean. True if the current value for the given path is equals to the second argument value. False otherwise.

---
### `was` (Available from v 1.2.0)
  **Parameters**
  - `path`: A string representing a path in JSON Pointer format as defined by the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901)
  - `value`: Any value.

  **Returns**
  Boolean. True if the original value before any change for the given path was equals to the second argument value. False otherwise.

---
### `clone` (Available from v 1.3.0)
  **No parameters**

  **Returns**
  Cloned Model with the plugin injected and the changes array reset to empty array.

  **Use cases**
  The `clone` method is usefull when you want to make changes to an already saved document in a `post-save` middleware. Why? Because if you
  make changes to the same document, that document instance will have all the previous changes that have already happened, so when you
  execute the `save` call over the document, the `pre-save` middleware will trigger again and could produce an infinite loop.

  **Example**

  Take this schema definition with the middlewares:
  ```javascript
  const schema = new mongoose.Schema({
    path1: String,
    path2: String,
    path3: String,
  });

  schema.pre('save', function(next){
    if(this.pathHasChanged('/path1')){
      this.path2 = 'Path 1 changed';
    }
    next();
  });

  schema.post('save', async function(document){
    if(this.pathHasChanged('/path2')){
      document.path3 = 'Path 2 updated in pre middleware';
      document.save();
    }
  });

  schema.post('save', function(document){
    if(this.pathHasChanged('/path3')){
      sideEffect();
    }
  });
  ```
  Now take this example and let's analyze the process:
  ```javascript
  const myModel = await mongoose.models.mymodel.findById(someid);
  myModel.path1 = "Changing path 1";
  await myModel.save();
  ```
  In this case when the line `myModel.path1 = "Changing path 1"` is executed, in the changes array we are going to have this:
  ```javascript
  [{path: "/path1", old_value: "Old's path1 value"}]
  ```
  And when the `save` method is called, we are going to go through the `pre-save` middlewares.
  So first we are going to go through this middleware:
  ```javascript
  schema.pre('save', function(next){
    if(this.pathHasChanged('/path1')){
      this.path2 = 'Path 1 changed';
    }
  });
  ```
  This line will be true:
  ```javascript
  this.pathHasChanged('/path1')`
  ```
  so the next line will be executed:
  ```javascript
  this.path2 = 'Path 1 changed';
  ```
  And now the changes array will have this value:
  ```javascript
  [
    {path: "/path2", old_value: "Old's path2 value"},
    {path: "/path1", old_value: "Old's path1 value"}
  ]
  ```
  Now the document is saved because there are not more `pre-save` middlewares, and now we start the `post-save` middlewares:
  ```javascript
  schema.post('save', function(document){
    if(this.pathHasChanged('/path2')){
      document.path3 = 'Path 2 updated in pre middleware';
      document.save();
    }
  });
  ```
  Now the execution of this line:
  ```javascript
  this.pathHasChanged('/path2')
  ```
  will resolve to `true`, so we will enter the `if`, and we will update the document through:
  ```javascript
  document.path3 = 'Path 2 updated in pre middleware';
  ```
  Which will update the changes array and now that array will be:
  ```javascript
  [
    {path: "/path3", old_value: "Old's path3 value"},
    {path: "/path2", old_value: "Old's path2 value"},
    {path: "/path1", old_value: "Old's path1 value"}
  ]
  ```
  Now the `save` method is called and guest what.... this is going to dispatch the execution of the `pre-save` middlewares again:
  ```javascript
  schema.pre('save', function(next){
    if(this.pathHasChanged('/path1')){
      this.path2 = 'Path 1 changed';
    }
  });
  ```
  The statement
  ```javascript
  this.pathHasChanged('/path1')
  ```
  will resolve to `true` and the line
  ```javascript
  this.path2 = 'Path 1 changed';
  ```
  will execute, although in this case the plugin won't insert another change because it will detect that current value is
  the same than the new value that we want to set, so we will skip it.

  Anyway, after this middleware execution we will write again to the database and we the `post-save` middleware will be
  executed again:
  ```javascript
  schema.post('save', function(document){
    if(this.pathHasChanged('/path2')){
      document.path3 = 'Path 2 updated in pre middleware';
      document.save();
    }
  });
  ```
  The 
  ```javascript
  this.pathHasChanged('/path2')
  ```
  will resolve to `true` because the changes array still is:
  ```javascript
  [
    {path: "/path3", old_value: "Old's path3 value"},
    {path: "/path2", old_value: "Old's path2 value"},
    {path: "/path1", old_value: "Old's path1 value"}
  ]
  ```
  So we will enter inside the `if` and the line
  ```javascript
  document.path3 = 'Path 2 updated in pre middleware';
  ```
  will be executed although any new change will be inserted because of the same reason given for the `pre-save` middleware case.
  But then the `save` method will be called again, and the `pre-save` middlewares will be called again... causing the infinite loop.

  In order to avoid this problem we need to call the `clone` method that will reset the plugin:
  ```javascript
  const schema = new mongoose.Schema({
    path1: String,
    path2: String,
    path3: String,
  });

  schema.pre('save', function(next){
    if(this.pathHasChanged('/path1')){
      this.path2 = 'Path 1 changed';
    }
    next();
  });

  schema.post('save', async function(document){
    if(this.pathHasChanged('/path2')){
      const cloned = document.clone();
      cloned.path3 = 'Path 2 updated in pre middleware';
      await cloned.save();
    }
  });

  schema.post('save', function(document){
    if(this.pathHasChanged('/path3')){
      sideEffect();
    }
  });
  ```
  So now we are going to repeat the exercise but using the `clone` method:
  ```javascript
  const myModel = await mongoose.models.mymodel.findById(someid);
  myModel.path1 = "Changing path 1";
  await myModel.save();
  ```
  As in the previous case
  ```javascript
  myModel.path1 = "Changing path 1"`
  ```
  is executed and in the changes array we are going to have this:
  ```javascript
  [{path: "/path1", old_value: "Old's path1 value"}]
  ```
  And when the `save` method is called, we are going to go through the `pre-save` middlewares.
  So first we are going to go through this middleware:
  ```javascript
  schema.pre('save', function(next){
    if(this.pathHasChanged('/path1')){
      this.path2 = 'Path 1 changed';
    }
  });
  ```
  This line will be true:
  ```javascript
  this.pathHasChanged('/path1')`
  ```
  so the next line will be executed:
  ```javascript
  this.path2 = 'Path 1 changed';
  ```
  And now the changes array will have this value:
  ```javascript
  [
    {path: "/path2", old_value: "Old's path2 value"},
    {path: "/path1", old_value: "Old's path1 value"}
  ]
  ```
  Now the document is saved because there are not more `pre-save` middlewares, and now we start the `post-save` middlewares:
  ```javascript
  schema.post('save', async function(document){
    if(this.pathHasChanged('/path2')){
      const cloned = document.clone();
      cloned.path3 = 'Path 2 updated in pre middleware';
      await cloned.save();
    }
  });
  ```
  Now the execution of this line:
  ```javascript
  this.pathHasChanged('/path2')
  ```
  will resolve to `true`, so we will enter the `if`, and we create a clone of the document:
  ```javascript
  const cloned = document.clone();
  ```
  And now instead of updating the original document we are going to update the cloned one:
  ```javascript
  cloned.path3 = 'Path 2 updated in pre middleware';
  ```
  Now if we check the changes of the cloned model we will have:
  ```javascript
  [{path: "/path3", old_value: "Old's path3 value"}]
  ```
  Now the `save` method is called:
  ```javascript
  await cloned.save();
  ```
  And the `pre-save` middlewares are triggered for this new instance:
  ```javascript
  schema.pre('save', function(next){
    if(this.pathHasChanged('/path1')){
      this.path2 = 'Path 1 changed';
    }
    next();
  });
  ```
  Now this statement:
  ```javascript
  this.pathHasChanged('/path1')
  ```
  will resolve to `false` because this instance's change's array is
  ```javascript
  [{path: "/path3", old_value: "Old's path3 value"}]
  ```
  So the code for this `pre-save` middleware will not execute, the actual `save` in the
  data base will happen, and now the `post-save` middlewares are trigger for this cloned
  model instance:
  ```javascript
  schema.post('save', async function(document){
    if(this.pathHasChanged('/path2')){
      const cloned = document.clone();
      cloned.path3 = 'Path 2 updated in pre middleware';
      await cloned.save();
    }
  });
  ```
  The statement
  ```javascript
  this.pathHasChanged('/path2')
  ```
  Will resolve to `false`, so the `post-save` middleware will be skipped, and the next `post-save`
  middleware will be executed for this cloned instance of the cloned model:
  ```javascript
  schema.post('save', function(document){
    if(this.pathHasChanged('/path3')){
      sideEffect();
    }
  });
  ```
  The statement 
  ```javascript
  this.pathHasChanged('/path3')
  ```
  Will resolve to `true` because remember that we are still executing this middlewares for the cloned
  model, and the cloned model changes array is just at this point:
  ```javascript
  [{path: "/path3", old_value: "Old's path3 value"}]
  ```
  So the `sideEffect` call will happen and this `post-save` middleware will finish its execution.

  Once this last `post-save` middleware finish, then the `await save()` from the first `post-save`
  middleware call where we made the clone will finish, and the last `post-save` middleware for the
  original model will be executed:
  ```javascript
  schema.post('save', function(document){
    if(this.pathHasChanged('/path3')){
      sideEffect();
    }
  });
  ```
  The statement
  ```javascript
  this.pathHasChanged('/path3')
  ```
  will resolve to `false` because now the changes array will be:
  ```javascript
  [
    {path: "/path2", old_value: "Old's path2 value"},
    {path: "/path1", old_value: "Old's path1 value"}
  ]
  ```

## Other technical questions
### The changes are stored in any particular order?
Yes. The changes are inserted at the begining of the changes array because when the changes are undone we undo every
change that affects to the requested path, in the reverted order, this means that we first undo the last inserted change
and the last change that will be reverted will be the first change that affects to the requested path.
This is done this way because we are seeking for the best performance and this way we do not have to revert the changes array.

### Why do you use the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901) JSON Pointer specification for the paths instead of the standard MongoDB dotted path format?
This plugin firstly was developed to resolve a problem that we have faced at [Walcu](https://walcu.com), and in Walcu we internally
use the [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901) JSON Pointer specification for the paths, so for us is natural
to work with this standard. And as we were seeking for performance, if we stored the path in the MongoDB dotted format, we had
to convert from [RFC 6901](https://datatracker.ietf.org/doc/html/rfc6901) format to the MongoDB dotted format, losing some performance.

When we thought about publishig this plugin, we thought to support both formats, but we wanted to keep things simple
(even though the implementation of the core concepts of this plugin is not simple at all).

### This looks cool. Where can I read more information about the implementation?
You can read the code and the comments where many of the tricky and dark magic things are explained through the comments.
