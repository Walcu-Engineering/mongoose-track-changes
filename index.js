const util = require('util');
const jsonpatch = require('fast-json-patch')

const proxy_handler = {
  apply: function (target, this_arg, arglist){
    const path = '/' + arglist[0].split('.').filter(p => p).join('/');
    const old_value = this_arg.get(arglist[0]);
    const change = {path, old_value};
    if(this_arg._changes){
      if(!this_arg._changes.some(change => change.path === path && util.isDeepStrictEqual(old_value, change.old_value))){//This change does not exist yet. (the same change could already exist because markModified is recursive
        this_arg._changes.unshift(change); //we insert the changes at the beggining of the array because if we have to revert the changes it is not neccesary to revert the array.
      }
    }else{
      this_arg._changes = [change];
    }
    const newtarget = target.bind(this_arg);
    newtarget(...arglist);
  }
};

const changesTracker = schema => {
  schema.post('init', function(doc){
    const $setProxy = new Proxy(doc.$set, proxy_handler);
    const setProxy = new Proxy(doc.set, proxy_handler);
    const markModifiedProxy = new Proxy(doc.markModified, proxy_handler);
    doc.$set = $setProxy;
    doc.set = setProxy;
    doc.markModified= markModifiedProxy;
  });

  schema.pre('save', function(next){
    if(this.isNew){
      const $setProxy = new Proxy(this.$set, proxy_handler);
      const setProxy = new Proxy(this.set, proxy_handler);
      const markModifiedProxy = new Proxy(this.markModified, proxy_handler);
      this.$set = $setProxy;
      this.set = setProxy;
      this.markModified= markModifiedProxy;
      this._changes = [{op: 'replace', path: '', old_value: undefined}]
    }
    next();
  });

  schema.pre('remove', function(next){
    this._changes = [{op: 'replace', path: '', old_value: this}]
    next();
  });

  /**
   * This method implements the getPreviousValue function that will be available
   * for all the models generated by Mongoose. Example:
   *
   * mongoose.models.test.findOne({}).then(document => { //document => {a: 1}
   *   document.getPreviousValue('/a'); // undefined
   *   document.a = 22;
   *   document.getPreviousValue('/a'); // 1
   *   document.c = 'test';
   *   document.getPreviousValue('/c'); // undefined;
   * })
   *
   * It receives a JSON pointer path as it's only argument and it will return the previous
   * value for the given JSON pointer path. If the path has not changed, then it will
   * return undefined. If the path did not exist, because you are setting a new path
   * then it will also return undefined because the path did not exist before you set it.
   *
   * PROBLEM: Changes have been made in deeply nested paths, but we want to read a partial nested path
   * Example:
   * We have this document:
   * {
   *   a: {
   *     b: {
   *       c1: 1,
   *       c2: 2,
   *       c3: 3,
   *     }
   *   }
   * }
   *
   * And two changes have been made:
   * [
   *   {op: 'replace', path: '/a/b/c2', value: 22},
   *   {op: 'replace', path: '/a/b/c3', value: 33},
   * ]
   *
   * So the resulting document is:
   * {
   *   a: {
   *     b: {
   *       c1: 1,
   *       c2: 22,
   *       c3: 33,
   *     }
   *   }
   * }
   * And in our changes array we will have this changes:
   * [
   *   {path: '/a/b/c2', old_value: 2},
   *   {path: '/a/b/c3', old_value: 3},
   * ]
   *
   * What happens if you call my_document.getPreviousValue('/a/b')?
   * In the changes array there is not any change for the path '/a/b'
   * so it may return undefined, but this is not actually true. That's why
   * we need to take all the changes whose path starts with the requested
   * path, and revert those changes for the partial subpath that has been
   * requested.
   *
   * An optimization that can be done is to do not do this process if there
   * is any change whose path is the same as the requested path.
   *
   * @param path: String with the format JSON pointer as defined in RFC6901
   */
  schema.methods.getPreviousValue = function(path){
    const path_change = (this._changes || []).find(change => change.path === path); //This is for the optimization. This should be the most used case.
    if(path_change){
      return path_change.old_value;
    }else{
      const affected_changes = (this._changes || []).filter(change => change.path.startsWith(path)); //Let's see if there are changes for more deeply nested paths than the requested path
      if(affected_changes.length > 0){//Shit! we have to do the complex process.
        const mongo_path = path.split('/').filter(p => p).join('.');
        const path_subdocument = this.get(mongo_path);
        const path_subobject = path_subdocument && path_subdocument.toObject() || {}; // to get a clone of the subdocument or an empty object if the subdocument does not exist. This is the new root document
        //if the change path is '/a/b/c/e' but the requested path is '/a/b', the change path with the new root is '/c/e';
        const revert_patch = affected_changes
          .map(change => ({path: change.path.replace(path, ''), ...(change.old_value === undefined ? ({op: 'remove'}) : ({op: 'replace', value: change.old_value}))}));
        return jsonpatch.applyPatch(path_subobject, revert_patch).newDocument;
      }else{//There are not changes for the given path
        return undefined;
      }
    }
  }

  schema.methods.pathHasChanged = function(path){
    return (this._changes || []).some(change => change.path === path);
  }
}

module.exports = changesTracker;
