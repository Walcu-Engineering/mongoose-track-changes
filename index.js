const util = require('util');
const jsonpatch = require('fast-json-patch')

const proxy_handler = {
  apply: function (target, this_arg, arglist){
    const path = '/' + arglist[0].split('.').filter(p => p).join('/');
    const old_value = this_arg.get(arglist[0]);
    const change = {path, old_value};
    if(this_arg._changes){
      if(!this_arg._changes.some(change => change.path === path && util.isDeepStrictEqual(old_value, change.old_value))){//This change does not exist yet. (the same change could already exist because markModified is recursive
        this_arg._changes.unshift(change); //we insert the changes at the beggining of the array because if we have to revert the changes it is not neccesary to revert the array.
      }
    }else{
      this_arg._changes = [change];
    }
    const newtarget = target.bind(this_arg);
    newtarget(...arglist);
  }
};

const changesTracker = schema => {
  schema.post('init', function(doc){
    const $setProxy = new Proxy(doc.$set, proxy_handler);
    const setProxy = new Proxy(doc.set, proxy_handler);
    const markModifiedProxy = new Proxy(doc.markModified, proxy_handler);
    doc.$set = $setProxy;
    doc.set = setProxy;
    doc.markModified= markModifiedProxy;
  });

  schema.pre('save', function(next){
    if(this.isNew){
      const $setProxy = new Proxy(this.$set, proxy_handler);
      const setProxy = new Proxy(this.set, proxy_handler);
      const markModifiedProxy = new Proxy(this.markModified, proxy_handler);
      this.$set = $setProxy;
      this.set = setProxy;
      this.markModified= markModifiedProxy;
      this._changes = [{op: 'replace', path: '', old_value: undefined}]
    }
    next();
  });

  schema.pre('remove', function(next){
    this._changes = [{op: 'replace', path: '', old_value: this}]
    next();
  });

  /**
   * This method implements the getPreviousValue function that will be available
   * for all the models generated by Mongoose. Example:
   *
   * mongoose.models.test.findOne({}).then(document => { //document => {a: 1}
   *   document.getPreviousValue('/a'); // undefined
   *   document.a = 22;
   *   document.getPreviousValue('/a'); // 1
   *   document.c = 'test';
   *   document.getPreviousValue('/c'); // undefined;
   * })
   *
   * It receives a JSON pointer path as it's only argument and it will return the previous
   * value for the given JSON pointer path. If the path has not changed, then it will
   * return undefined. If the path did not exist, because you are setting a new path
   * then it will also return undefined because the path did not exist before you set it.
   *
   * PROBLEM: Changes have been made in deeply nested paths, but we want to read a partial nested path
   * Example:
   * We have this document:
   * {
   *   a: {
   *     b: {
   *       c1: 1,
   *       c2: 2,
   *       c3: 3,
   *     }
   *   }
   * }
   *
   * And two changes have been made:
   * [
   *   {op: 'replace', path: '/a/b/c2', value: 22},
   *   {op: 'replace', path: '/a/b/c3', value: 33},
   * ]
   *
   * So the resulting document is:
   * {
   *   a: {
   *     b: {
   *       c1: 1,
   *       c2: 22,
   *       c3: 33,
   *     }
   *   }
   * }
   * And in our changes array we will have this changes:
   * [
   *   {path: '/a/b/c2', old_value: 2},
   *   {path: '/a/b/c3', old_value: 3},
   * ]
   *
   * What happens if you call my_document.getPreviousValue('/a/b')?
   * In the changes array there is not any change for the path '/a/b'
   * so it may return undefined, but this is not actually true. That's why
   * we need to take all the changes whose path starts with the requested
   * path, and revert those changes for the partial subpath that has been
   * requested.
   *
   * An optimization that can be done is to do not do this process if there
   * is any change whose path is the same as the requested path.
   *
   * @param path: String with the format JSON pointer as defined in RFC6901
   */
  schema.methods.getPreviousValue = function(path){
    const path_change = (this._changes || []).find(change => change.path === path); //This is for the optimization. This should be the most used case.
    if(path_change){
      return path_change.old_value;
    }else{
      const affected_changes = (this._changes || []).filter(change => change.path.startsWith(path)); //Let's see if there are changes for more deeply nested paths than the requested path
      if(affected_changes.length > 0){//Shit! we have to do the complex process.
        const mongo_path = path.split('/').filter(p => p).join('.');
        const path_subdocument = this.get(mongo_path);
        const path_subobject = path_subdocument && path_subdocument.toObject() || {}; // to get a clone of the subdocument or an empty object if the subdocument does not exist. This is the new root document
        //if the change path is '/a/b/c/e' but the requested path is '/a/b', the change path with the new root is '/c/e';
        const revert_patch = affected_changes
          .map(change => ({path: change.path.replace(path, ''), ...(change.old_value === undefined ? ({op: 'remove'}) : ({op: 'replace', value: change.old_value}))}));
        return jsonpatch.applyPatch(path_subobject, revert_patch).newDocument;
      }else{//There are not changes for the given path
        return undefined;
      }
    }
  }

  /*
   * In this function we will have a similar problem than the one we had to
   * address in the previous function:
   *
   * Given a change to the path '/a/b', if the pathHasChanged function is called
   * for the path 'a/b/c/d' we cannot determine if that path has actually
   * changed or not by just checking the changes paths.
   *
   * In order to resolve this we have to check if there is a change whose's path
   * is an ancestor of the requested path. If this is the case, then we have to
   * take the whole ancestor's old value, and compare the nested old value with
   * the current nested old value and check if it is the same in order to
   * determine if the requested path has changed or not.
   */
  schema.methods.pathHasChanged = function(path){
    if((this._changes || []).some(change => change.path === path)) return true; //This should be the most common case
    //Ok, we are not lucky so we have to check if there is any change whose's
    //path is an ancestor for the requested path
    const ancestor_changes = (this._changes || []).filter(change => path.startsWith(change.path));
    // If there aren't any changes whose path is an ancestor of the requested
    // path means that there has not been any change that involves the requested
    // path, so the requested path has not changed, and we can stop the execution
    // of the function only for performance reasons
    if(ancestor_changes.length === 0) return false;
    //If there are several changes that affect to ancestors, we have to check
    //all the changes because if the nearest ancestor has not the change, it
    //does not mean that another change that is a farther ancestor includes
    //a change for the nested path.
    return ancestor_changes.some(ancestor_change => {
      //Now the old_value of the ancestor_change is where we have to
      //check if the value has changed or not, but now we cannot use the
      //requested path because if the requested path was '/a/b/c/d/e' and
      //the ancestor path is '/a/b/c', we have to check the subpath
      //'/d/e'. So we have to extract the subpath from the requested path
      const subpath = path.split(ancestor_change.path)[1];
      //Once we have the subpath, we have to read the old value, and we need
      //a function in order to achieve this because we have to take into
      //account this scenario:
      //
      //old value for path '/a/b/c' is {d: {e: 1}}; but the requested subpath
      //is /d/e/f' that path does not exist in old value, so we need a mechanism
      //that given that path returns undefined.
      const old_subpath_value = subpath.split('/').filter(p => p).reduce((subpath_part_value, subpath_part, i, path_array) => {
        if(subpath_part_value == null){
          if(i < path_array.length - 1) return {};
          return subpath_part_value;
        }
        return subpath_part_value[subpath_part];
      }, ancestor_change.old_value);
      if(old_subpath_value === undefined) return false; // this means that the requested subpath is not present in the old value, so that subpath has not changed
      //If we reach this line means that the subpath was present in the old value,
      //so we have to compare the old value with the current one to determine if
      //the value has changed or not.
      const mongo_nested_path = path.split('/').filter(p => p).join('.');
      const current_nested_value = this.get(mongo_nested_path);
      return util.isDeepStrictEqual(current_nested_value, old_subpath_value);
    });
  }
}

module.exports = changesTracker;
